<!DOCTYPE html>
<html lang="en-US">
 <head>
	<title>Sover the Cursetris</title>
	<meta charset="UTF-8">
  <style>
	
	html, body { height: 100%; margin: 0; }
	body {
		background-color: gray;
		
		background-color: #3A3A3A;
	}
	
	canvas {
		position: absolute;
		top: 0;
		left: 0;
	}
	
	input {
		width: 4vw;
	}
	
	body, button, input {
		color: white;
		
		font: 0.9vw Consolas;
	}
	
	label {
		/*text-shadow: 0.1vw 0.1vh black;*/ /*Needed if the menu is brighter*/
	}
	
	
	button, input {
		background-color: #555555;
	}
	
	input[type=checkbox] {
		width: 1vw;
		margin-left: -0.5vw;
	}
	
	
	/*This part is really cool*/
	
	a:link, a:visited { color: #f0f0f0; }
	a:hover {
		background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);
		
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
	}
	a:active {
		background: linear-gradient(45deg, #5BCEFA, #F5A9B8, #f0f0f0, #F5A9B8, #5BCEFA);
		
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
	}
	
  </style>
 </head>
 <body>
 <div id="menuDiv" style="position: absolute; text-align: center; width: 100%;"></div>
 <div id="gameDiv" style="position: absolute; display: none;">
 <canvas id="canvasId"></canvas>
 </div>

<script> //Variables
	
	//if you're use notepad++, press Alt+3 to collapse all of the scripts
	
	var canvas = document.getElementById("canvasId");
	var ctx = canvas.getContext("2d");
	canvas.oncontextmenu = function(){return false;}
	canvas.height = window.innerHeight; //969
	canvas.width = window.innerWidth; //1920
	
	let fps = 60;
	
	let xyArr = ["x", "y"];
	
	
	//keyboard/gamepad
	let keyboardAxes = {
		x: {negative: ["KeyA","ArrowLeft"], positive: ["KeyD","ArrowRight"]},
		y: {negative: ["KeyW","ArrowUp"], positive: ["KeyS","ArrowDown"]}
	};
	
	let gamepads = navigator.getGamepads();
	let gamepadAxisRange = {min: 0.55, max: 1};
	
	let gamepadDpadAxes = {
		x: {negative: [14], positive: [15]},
		y: {negative: [12], positive: [13]}
	}
	
	let inputButtons = {
		rotateRight: {keyboard: ["KeyX","ArrowUp","KeyW","KeyK"], gamepads: [[1,3],[1,3],[1,3],[1,3]], timer: 0, maxTimer: 12, functionName: "onRotateRight"},
		
		rotateLeft: {keyboard: ["KeyZ","KeyJ"], gamepads: [[0,2],[0,2],[0,2],[0,2]], timer: 0, maxTimer: 12, functionName: "onRotateLeft"},
		
		teleportMovement: {keyboard: ["KeyA","KeyS","KeyD","KeyF","KeyG","KeyH","KeyJ","KeyK","KeyL","Semicolon"],
						   gamepads: [[14,12,4,6,15,2,3,5,7,1],[14,12,4,6,15,2,3,5,7,1],[14,12,4,6,15,2,3,5,7,1],[14,12,4,6,15,2,3,5,7,1]],
						   timer: 0, maxTimer: 0, functionName: "moveTeleportMovementPiece", functionArgs: "pressedNum",
						   condition: {arrPath: ["rules","teleportMovement"], target: true}
		},
		teleportRotateRight: {keyboard: ["KeyY","KeyU","KeyI","KeyO","KeyP","BracketLeft","BracketRight","KeyN","KeyM","Comma","Period","Slash"],
							  gamepads: [[0],[0],[0],[0]], timer: 0, maxTimer: 12, functionName: "onRotateRight", functionArgs: true,
							  condition: {arrPath: ["rules","teleportMovement"], target: true}
		},
		teleportRotateLeft: {keyboard: ["KeyQ","KeyW","KeyE","KeyR","KeyT","KeyZ","KeyX","KeyC","KeyV","KeyB"],
							 gamepads: [[13],[13],[13],[13]], timer: 0, maxTimer: 12, functionName: "onRotateLeft", functionArgs: true,
							 condition: {arrPath: ["rules","teleportMovement"], target: true}
		},
		teleportDrop: {keyboard: ["Space"], gamepads: [[10,11],[10,11],[10,11],[10,11]], timer: 0, maxTimer: 0, functionName: "dropCurrentPiece",
					   condition: {arrPath: ["rules","teleportMovement"], target: true}
		}
	}
	let defaultInputButtons = structuredClone(inputButtons);
	
	inputButtonStates = {};
	
	let inputButtonRebindLayout = [
		{
			text: "Rotation",
			buttons: [
				{text: "Rotate Left", type: "rotateLeft"},
				{text: "Rotate Right", type: "rotateRight"}
			]
		},
		{
			text: "Teleport Movement",
			buttons: [
				{text: "Teleport Movement Teleport (ordered left-to-right)", type: "teleportMovement"},
				{text: "Teleport Movement Rotate Left", type: "teleportRotateLeft"},
				{text: "Teleport Movement Rotate Right", type: "teleportRotateRight"},
				{text: "Teleport Movement Drop", type: "teleportDrop"}
			]
		}
	];
	
	let selectedRebindButton = "";
	
	
	//mouse
	let mousePos = {x: 0, y: 0};
	let mousePosRatio = {x: 0, y: 0};
	
	let lastMousePos = {x: 0, y: 0};
	let lastMousePosRatio = {x: 0, y: 0};
	
	let isMouseDown = false;
	let mouseButton = -1;
	
	//camera
	let cameraState = {camera: true, zoom: true, shouldLockMouse: false};
	
	let camera = {x: -5, y: -9, speed: 0, zoom: {level: 0.02, min: 0.02, max: 2, speed: 0, scrollSpeed: 0}, areDimentionsEqual: true};
	
	let mouseLockFrames = 0;
	
	
	//colors
	
	let colors = {
		white: "#f0f0f0",
		black: "#000000",
		background: "#626262",
		debugText: "#AAAAAA"
	}
	
	let levelColors = [
		[["#f0f0f0","#d162a4"],["#ff9a56","#f0f0f0"],["#d162a4","#f0f0f0"]],
		[["#f0f0f0","#d162a4"],["#a30262","#f0f0f0"],["#d162a4","#f0f0f0"]],
		[["#f0f0f0","#5049cc"],["#7bade2","#f0f0f0"],["#5049cc","#f0f0f0"]],
		
		[["#222222","#5bcefa"],["#f5a9b8","#222222"],["#5bcefa","#222222"]]
	];
	
	let emptyColors = ["#222222","#222222"];//,"#444444"];
	let ghostColors = ["#88444488", "#44884488", "#44448888", "#88448888", "#88884488", "#44888888"];
	
	for (let i in levelColors){
		levelColors[i][-1] = emptyColors;
	}
	
	//buttons (currently unused)
	let buttons = {}; //ex: {menu: [{pos: {x: 0.5, y: 0.5, w: 0.2, h: 0.1}, onclick: {f: "funcName", args: 12}}]};
	
	let clickedButton = {i: "", j: 0};
	
	let closestButton = {i: "", j: 0, distance: -1};
	
	
	//menu
	
	var isInRebindControls = false;
	
	
	//game
	
	let board = [];
	let boardData = {w: 10, h: 20, border: 0.075};
	let tallerBoard = []; //for rotating I pieces above the board
	
	let shouldDrawControls = true;
	
	let currentLevel = 0;
	let lineClearNums = {horizontal: 0, vertical: 0};
	let previousScoreNum = 0;
	let lineClearsPerLevel = 10;
	let currentFallingSpeed = 30;
	
	let currentPiece = {x: 5, y: 0, pieceNum: 0, rotationNum: 0, hasReleasedDown: true, startingPos: {x: 5, y: 0}};
	let nextPieceNums = [];
	
	
	//I L J T S Z O
	pieceStartingY = [0,0,0,0,0,0,1];
	pieceColorsNums = [0,2,1,0,1,2,0, 2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,
						2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,
						2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,2,1,0,1,2,0,]; //this could be prettier but hey
	
	let cursedPieces = {min: 7, max: 33};
	let specialPieceNums = {checkerboard: 34, hardest5x5: 35, hardest5x5Mirrored: 36};
	let specialPieceDescriptions = {checkerboard: "Checkerboard (10 by 5)", hardest5x5: "Hardest 5 by 5 Nonogram Board (Channel Icon)"};
	
	let specialPieceNames = [];
	for (let i in specialPieceNums){ specialPieceNames[specialPieceNums[i]] = i; }
	
	
	let multipleChoiceChoices = [];
	let isCurrentlyMultipleChoice = false;
	
	
	var rules = {clearHorizontal: true, clearVertical: false, verticalLineHeight: 16, minConsecutiveLineClears: 1, noEasyPieces: false, noHardPieces: false,
				teleportMovement: false, invertedRotation: false, cursedPiecesChance: 0.166, cursedPiecesChanceMultiplierPerHole: 0.875,
				solverTakeoverChances: {easyPiece: 0, hardPiece: 0, cursedPiece: 0}, solverTimer: {num: 0, max: 4},
				multipleChoiceChance: 0, isMultipleChoiceOrdered: false,
				pieceGravity: false, gravityTimer: {num: 0, max: 8},
				nextPieceDepth: 1, startingPieceNums: [], movementTimer: {x: 30, y: 30, max: {x: 6, y: 36}}, fallingSpeedMultiplierPerClear: 0.99 
	};
	
	let defaultRules = structuredClone(rules);
	
	let rulesPresets = {
		"Uncursed": {
			clearHorizontal: true, clearVertical: false, minConsecutiveLineClears: 1, noEasyPieces: false, noHardPieces: false,
			teleportMovement: false, cursedPiecesChance: 0, cursedPiecesChanceMultiplierPerHole: 0,
			solverTakeoverChances: {easyPiece: 0, hardPiece: 0, cursedPiece: 0},
			multipleChoiceChance: 0, pieceGravity: false, startingPieceNums: []
		},
		"Tetrises-only": {
			minConsecutiveLineClears: 4
		},
		"Default Cursed%": {
			cursedPiecesChance: 0.166, cursedPiecesChanceMultiplierPerHole: 0.875
		},
		"High Cursed%": {
			cursedPiecesChance: 0.34, cursedPiecesChanceMultiplierPerHole: 0.875
		},
		"Long Piece List": {
			nextPieceDepth: 6
		},
		
		"Cursed-only Solver": {
			solverTakeoverChances: {easyPiece: 0, hardPiece: 0, cursedPiece: 1}
		},
		"Cursed-less Solver": {
			solverTakeoverChances: {easyPiece: 1, hardPiece: 1, cursedPiece: 0}
		},
		"Hard-Cursed Solver": {
			solverTakeoverChances: {easyPiece: 0, hardPiece: 1, cursedPiece: 1}
		},
		"No Solver": {
			solverTakeoverChances: {easyPiece: 0, hardPiece: 0, cursedPiece: 0}
		},
		"Half Solver": {
			solverTakeoverChances: {easyPiece: 0.5, hardPiece: 0.5, cursedPiece: 0.5}
		},
		
		"High Solver": {
			solverTakeoverChances: {easyPiece: 0.75, hardPiece: 0.75, cursedPiece: 0.75}
		},
		"Max Solver": {
			solverTakeoverChances: {easyPiece: 1, hardPiece: 1, cursedPiece: 1}
		},
		"Only Easy Pieces": {
			noEasyPieces: false, noHardPieces: true, cursedPiecesChance: 0,
		},
		"Only Hard Pieces": {
			noEasyPieces: true, noHardPieces: false, cursedPiecesChance: 0,
		},
		"Only Cursed Pieces": {
			noEasyPieces: true, noHardPieces: true, cursedPiecesChance: 1,
		},
		
		"Default Vertical-only": {
			clearHorizontal: false, clearVertical: true, verticalLineHeight: 16
		},
		"Multiple-Choice": {
			multipleChoiceChance: 1, isMultipleChoiceOrdered: false
		},
		"50% Multiple-Choice": {
			multipleChoiceChance: 0.5,
		},
		
		"Easy Gravity": {
			clearHorizontal: true, clearVertical: true, verticalLineHeight: 4, pieceGravity: true,
		},
		"Difficult Gravity": {
			clearHorizontal: true, clearVertical: true, verticalLineHeight: 12, pieceGravity: true,
		},
		
		"Checkerboard Piece": {
			startingPieceNums: [specialPieceNums.checkerboard],
		},
		"Channel Icon Piece": {
			startingPieceNums: [specialPieceNums.hardest5x5],
		},
		
		"Reset to Default": defaultRules,
	};
	
	//ideas: 33.3 solver and 50% multiple-choice, clear a line with 2,2 speed
	
	
	
	
	
	let currentVersion = "v1.1";
	
	let versionLogs = [ //Not yet displayed anywhere
		["v1.1 (July 4, 2024)",
			"Piece Gravity", "Basic Rebind Controls", "Falling Speed Multiplier per Cleared Line", "Vertical Clear Height Indicator Line", "Renamed Keyboard Movement to Teleport Movement since it works with the controller as well now", "Other Smaller Changes"
		],
		["v1.0 (June 20, 2024)",
			"Initial Release"
		]
	];
	
	
</script>
<script> //Pieces
	
	let pieces = [
		[
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[1,1,1,1,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,0,0]
			]
		],
		[
			[
				[0,0,0],
				[1,1,1],
				[1,0,0]
			],
			[
				[1,1,0],
				[0,1,0],
				[0,1,0]
			],
			[
				[0,0,1],
				[1,1,1],
				[0,0,0]
			],
			[
				[0,1,0],
				[0,1,0],
				[0,1,1]
			],
		],
		[
			[
				[0,0,0],
				[1,1,1],
				[0,0,1]
			],
			[
				[0,1,0],
				[0,1,0],
				[1,1,0]
			],
			[
				[1,0,0],
				[1,1,1],
				[0,0,0]
			],
			[
				[0,1,1],
				[0,1,0],
				[0,1,0]
			],
		],
		[
			[
				[0,0,0],
				[1,1,1],
				[0,1,0]
			],
			[
				[0,1,0],
				[1,1,0],
				[0,1,0]
			],
			[
				[0,1,0],
				[1,1,1],
				[0,0,0]
			],
			[
				[0,1,0],
				[0,1,1],
				[0,1,0]
			],
		],
		[
			[
				[0,0,0],
				[0,1,1],
				[1,1,0]
			],
			[
				[0,1,0],
				[0,1,1],
				[0,0,1]
			]
		],
		[
			[
				[0,0,0],
				[1,1,0],
				[0,1,1]
			],
			[
				[0,0,1],
				[0,1,1],
				[0,1,0]
			]
		],
		[
			[
				[1,1,0],
				[1,1,0],
				[0,0,0]
			]
		],
		[ //7
			[
				[0,1,0],
				[1,0,1],
				[0,1,0]
			]
		],
		[ //8
			[
				[0,0,0,0,0],
				[0,0,0,1,0],
				[1,1,1,0,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,0,1,1,1],
				[0,1,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0]
			]
		],
		[ //9
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[1,1,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,0]
			],
			[
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,1,0,0,0],
				[0,0,1,1,1],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0]
			]
		],
		[ //10
			[
				[1,0,0],
				[0,1,0],
				[1,1,0]
			],
			[
				[1,0,1],
				[1,1,0],
				[0,0,0]
			],
			[
				[0,1,1],
				[0,1,0],
				[0,0,1]
			],
			[
				[0,0,0],
				[0,1,1],
				[1,0,1]
			]
		],
		[ //11
			[
				[0,0,1],
				[0,1,0],
				[0,1,1]
			],
			[
				[0,0,0],
				[1,1,0],
				[1,0,1]
			],
			[
				[1,1,0],
				[0,1,0],
				[1,0,0]
			],
			[
				[1,0,1],
				[0,1,1],
				[0,0,0]
			]
		],
		[ //12
			[
				[1,0,0],
				[1,1,0],
				[0,0,1]
			],
			[
				[0,1,1],
				[0,1,0],
				[1,0,0]
			],
			[
				[1,0,0],
				[0,1,1],
				[0,0,1]
			],
			[
				[0,0,1],
				[0,1,0],
				[1,1,0]
			]
		],
		[ //13
			[
				[1,1,0],
				[0,1,0],
				[0,0,1]
			],
			[
				[0,0,1],
				[0,1,1],
				[1,0,0]
			],
			[
				[1,0,0],
				[0,1,0],
				[0,1,1]
			],
			[
				[0,0,1],
				[1,1,0],
				[1,0,0]
			]
		],
		[ //14
			[
				[0,1,0],
				[1,1,0],
				[0,0,1]
			],
			[
				[0,1,0],
				[0,1,1],
				[1,0,0]
			],
			[
				[1,0,0],
				[0,1,1],
				[0,1,0]
			],
			[
				[0,0,1],
				[1,1,0],
				[0,1,0]
			]
		],
		[ //15
			[
				[1,0,0],
				[1,0,1],
				[0,1,0]
			],
			[
				[0,1,1],
				[1,0,0],
				[0,1,0]
			],
			[
				[0,1,0],
				[1,0,1],
				[0,0,1]
			],
			[
				[0,1,0],
				[0,0,1],
				[1,1,0]
			]
		],
		[ //16
			[
				[0,0,1],
				[1,0,1],
				[0,1,0]
			],
			[
				[0,1,0],
				[1,0,0],
				[0,1,1]
			],
			[
				[0,1,0],
				[1,0,1],
				[1,0,0]
			],
			[
				[1,1,0],
				[0,0,1],
				[0,1,0]
			]
		],
		[ //17
			[
				[0,0,1],
				[0,0,1],
				[1,1,0]
			],
			[
				[1,0,0],
				[1,0,0],
				[0,1,1]
			],
			[
				[0,1,1],
				[1,0,0],
				[1,0,0]
			],
			[
				[1,1,0],
				[0,0,1],
				[0,0,1]
			]
		],
		[ //18
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,1,1,0,0],
				[1,0,0,1,0],
				[0,0,0,0,0]
			],
			[
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,1,0,0,1],
				[0,0,1,1,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,1,0]
			]
		],
		[ //19
			[
				[0,0,0,0,0],
				[0,0,0,1,0],
				[0,1,1,0,0],
				[1,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,0]
			]
		],
		[ //20
			[
				[0,0,0,0,0],
				[1,0,0,0,0],
				[0,1,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,0,0,0]
			]
		],
		[ //21
			[
				[0,0,0,0,0],
				[1,1,0,0,0],
				[0,0,1,1,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,1,0],
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,0,0]
			]
		],
		[ //22
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,0,1,1,0],
				[1,1,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,1,0,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,0,0]
			]
		],
		[ //23
			[
				[1,0,0,0,0],
				[0,1,0,0,0],
				[0,0,1,1,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,1],
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,1,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,1]
			],
			[
				[0,0,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[1,0,0,0,0]
			]
		],
		[ //24
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,0,1,1,0],
				[0,1,0,0,0],
				[1,0,0,0,0]
			],
			[
				[1,0,0,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,1],
				[0,0,0,1,0],
				[0,1,1,0,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,1]
			]
		],
		[ //25
			[
				[0,0,0,0,0],
				[0,1,0,0,0],
				[1,0,1,1,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,1,0,0],
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,1,1,0,1],
				[0,0,0,1,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0]
			]
		],
		[ //26
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[1,0,1,1,0],
				[0,1,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,0,1,0],
				[0,1,1,0,1],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,1,0,0],
				[0,0,1,0,0],
				[0,0,0,1,0],
				[0,0,1,0,0]
			]
		],
		[ //27
			[
				[1,0,1],
				[0,1,0],
				[0,1,0]
			],
			[
				[0,0,1],
				[1,1,0],
				[0,0,1]
			],
			[
				[0,1,0],
				[0,1,0],
				[1,0,1]
			],
			[
				[1,0,0],
				[0,1,1],
				[1,0,0]
			]
		],
		[ //28
			[
				[1,0,0,0,0],
				[0,1,0,1,0],
				[0,0,1,0,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,1],
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,0,1,0,0],
				[0,1,0,1,0],
				[0,0,0,0,1]
			],
			[
				[0,0,0,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[1,0,0,0,0]
			]
		],
		[ //29
			[
				[0,0,0,0,1],
				[0,1,0,1,0],
				[0,0,1,0,0],
				[0,0,0,0,0],
				[0,0,0,0,0]
			],
			[
				[0,0,0,0,0],
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,1]
			],
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,0,1,0,0],
				[0,1,0,1,0],
				[1,0,0,0,0]
			],
			[
				[1,0,0,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,0,0,0]
			]
		],
		[ //30
			[
				[1,0,1],
				[0,1,0],
				[0,0,1]
			],
			[
				[0,0,1],
				[0,1,0],
				[1,0,1]
			],
			[
				[1,0,0],
				[0,1,0],
				[1,0,1]
			],
			[
				[1,0,1],
				[0,1,0],
				[1,0,0]
			]
		],
		[ //31
			[
				[0,0,0,0,1],
				[0,0,0,1,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,0,0,0]
			],
			[
				[1,0,0,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,0,0,1,0],
				[0,0,0,0,0]
			]
		],
		[ //32
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[0,1,0,1,0],
				[1,0,1,0,0],
				[0,0,0,0,0]
			],
			[
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,0,0,0,0]
			]
		],
		[ //33
			[
				[0,0,0,0,0],
				[0,0,0,0,0],
				[1,0,1,0,0],
				[0,1,0,1,0],
				[0,0,0,0,0]
			],
			[
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,1,0,0],
				[0,1,0,0,0],
				[0,0,0,0,0]
			]
		],
		[ //34
			[
				[1,0,1,0,1,0,1,0,1,0],
				[0,1,0,1,0,1,0,1,0,1],
				[1,0,1,0,1,0,1,0,1,0],
				[0,1,0,1,0,1,0,1,0,1],
				[1,0,1,0,1,0,1,0,1,0]
			]
		],
		[ //35
			[
				[0,0,1,1,0],
				[1,0,0,1,1],
				[1,1,0,0,1],
				[0,1,1,1,0],
				[0,0,1,0,0]
			],
			[
				[0,0,1,1,0],
				[0,1,1,0,0],
				[1,1,0,0,1],
				[0,1,0,1,1],
				[0,0,1,1,0]
			],
			[
				[0,0,1,0,0],
				[0,1,1,1,0],
				[1,0,0,1,1],
				[1,1,0,0,1],
				[0,1,1,0,0]
			],
			[
				[0,1,1,0,0],
				[1,1,0,1,0],
				[1,0,0,1,1],
				[0,0,1,1,0],
				[0,1,1,0,0]
			]
		],
	];
	
</script>

<script> //Menu
	
	function getRuleValueFromArrPath(arrPath){
		let value = rules;
		
		for (let i in arrPath){
			value = value[arrPath[i]];
		}
		return value;
	}
	
	
	function onMenuInputChange(id, isPercentage, canGoOver100){
		if (document.getElementById(id).value == ""){
			document.getElementById(id).value = 0;
		}
		
		if (document.getElementById(id).value < 0){
			document.getElementById(id).value *= -1;
		}
		
		if (isPercentage){
			if (!canGoOver100){
				while (document.getElementById(id).value > 100){
					document.getElementById(id).value /= 10;
				}
			}
		} else{
			document.getElementById(id).value = Math.round(document.getElementById(id).value);
		}
	}
	
	
	function rulesPresetsClick(type){
		changeRulesByMenu();
		
		let arr = rulesPresets[type];
		
		for (let i in arr){
			rules[i] = arr[i];
		}
		
		generateMenu();
	}
	
	
	function removeStartingPiece(){
		rules.startingPieceNums = [];
		
		generateMenu();
	}
	
	
	let menuExplanations = {
		clearHorizontal: "Remove horizontal rows that are fully filled up",
		clearVertical: "Remove vertical columns that are filled up to the Vertical Line Height",
		verticalLineHeight: "This is how many blocks are need to be filled in from the bottom for the Vertical Clears to learn a column",
		movementTimerMaxX: "How many frames it takes for a piece to move left or right, 1 frame is 1/60th of a second",
		movementTimerMaxY: "How many frames it takes for a piece to fall one block, 1 frame is 1/60th of a second",
		fallingSpeedMultiplierPerClear: "If this is below 100% then the game speeds up for each cleared line\n(Falling Speed is multiplied by this for each clear)",
		pieceGravity: "Blocks fall down if they would be in the air otherwise, fallen blocks turn into a different color, lines can only be cleared if either none of them all fallen blocks or all of them are fallen blocks.\n\nPlaying with both Horizontal Clears and Vertical Clears is recommended.",
		gravityTimer: "How many frames it takes for a piece to fall if the Piece Gravity is on, 1 frame is 1/60th of a second",
		nextPieceDepth: "How many pieces you can see in advance on the side of the board",
		invertedRotation: "Changes rotation from left/right to right/left",
		noEasyPieces: "Removes these basic pieces: I L J T",
		noHardPieces: "Removes these basic pieces: Z S O",
		cursedPiecesChance: "How likely cursed pieces are, cursed pieces are pieces that are made out of 4 blocks but some of them are only diagonally connected",
		cursedPiecesChanceMultiplierPerHole: "How much the Cursed Pieces Chance should be multiplied by for each hole on the board, if it's less than 100% then cursed pieces get less likely the more holes there are. A 'hole' is an empty space that has a block somewhere above it",
		minConsecutiveLineClears: "Normally a line is cleared if it's fully filled in, even when it's only 1 block tall. If you change this to 4 for example, lines will only get cleared if 4 of them are filled in on top of each other",
		solverTakeoverChances: "How likely is it that the computer puts down a piece instead of you",
		solverTakeoverChancesEasyPiece: "How likely is it that the computer puts down an easy piece instead of you, easy pieces are the basic I L J T shapes",
		solverTakeoverChancesHardPiece: "How likely is it that the computer puts down a hard piece instead of you, hard pieces are the basic Z S O shapes",
		solverTakeoverChancesCursedPiece: "How likely is it that the computer puts down a cursed piece instead of you, cursed pieces are pieces that are made out of 4 blocks but some of them are only diagonally connected",
		solverTimer: "How many frames the computer should wait between putting down pieces, 1 frame is 1/60th of a second",
		multipleChoiceChance: "How likely is it that instead of having to move a piece, you get to choose from a few places to put your piece. You can choose by pressing the number keys",
		isMultipleChoiceOrdered: "When a Multiple-Choice happens, the numbers associated to the choices normally goes from left to right, but with this toggled, the numbers will go in order of how much the computer likes the move, 1 being to computers #1 choice",
		teleportMovement: "You teleport your pieces instead of moving them left-to-right\nYou teleport the center of the piece, which is highlighted in gray\nYou can use a keyboard or a controller, but you can only rebind the keyboard for now\n\nThe default controls:\nKeyboard: Middle row of the keyboard is the teleport, ASDFGHJKL; keys teleport the piece to their column\nOther letter keys rotate the piece, if they're on the left side of the keyboard they rotate it left and if they're on the right they rotate it right\nSpace drops down the piece faster\n\nController: The teleport from left-to-right is: Left, Up, Left Button, Left Trigger, Right, X, Y, Right Button, Right Trigger, B\nRotate left and right is Down and A\nPressing down either of the analog sticks makes the pieces drop down faster"
	};
	
	let menuTexts = [
		[
			{text: "Horizontal Clears", title: "clearHorizontal"}, {checkBox: {arrPath: ["clearHorizontal"]}},
			{text: "Vertical Clears", title: "clearVertical"}, {checkBox: {arrPath: ["clearVertical"]}},
			{text: "Vertical Line Height:", title: "verticalLineHeight"}, {numInput: {arrPath: ["verticalLineHeight"]}}, {text: "blocks (out of 20)"}
		],
		[
			{text: "Movement Speed:", title: "movementTimerMaxX"}, {numInput: {arrPath: ["movementTimer","max","x"]}}, {text: "frames"}, {gap: true},
			{text: "Falling Speed:", title: "movementTimerMaxY"}, {numInput: {arrPath: ["movementTimer","max","y"]}}, {text: "frames"}, {gap: true},
			{text: "Falling Speed Multiplier:", title: "fallingSpeedMultiplierPerClear"}, {numInput: {arrPath: ["fallingSpeedMultiplierPerClear"], isPercentage: true}}
		],
		[
			{text: "Next Piece List Size:", title: "nextPieceDepth"}, {numInput: {arrPath: ["nextPieceDepth"]}}, {text: "pieces"}, {gap: true},
			{text: "Inverted Rotation", title: "invertedRotation"}, {checkBox: {arrPath: ["invertedRotation"]}},
			{button: {text: "Rebind Controls", onclick: "generateRebindControlsMenu()"}},
		],
		[
			{text: "Disable Easy Pieces", title: "noEasyPieces"}, {checkBox: {arrPath: ["noEasyPieces"]}},
			{text: "Disable Hard Pieces", title: "noHardPieces"}, {checkBox: {arrPath: ["noHardPieces"]}}
		],
		[
			{text: "Smallest Consecutive Line Clears:", title: "minConsecutiveLineClears"}, {numInput: {arrPath: ["minConsecutiveLineClears"]}}, {text: "lines"}
		],
		[],
		[
			{text: "Cursed Pieces Chance:", title: "cursedPiecesChance"}, {numInput: {arrPath: ["cursedPiecesChance"], isPercentage: true}}, {gap: true},
			{text: "Cursed Pieces Chance Multiplier per Hole:", title: "cursedPiecesChanceMultiplierPerHole"}, {numInput: {arrPath: ["cursedPiecesChanceMultiplierPerHole"], isPercentage: true, canGoOver100: true}}
		],
		[
			{text: "Piece Gravity", title: "pieceGravity"}, {checkBox: {arrPath: ["pieceGravity"]}},
			{text: "Gravity Speed:", title: "gravityTimer"}, {numInput: {arrPath: ["gravityTimer","max"]}}, {text: "frames"}
		],
		[
			{text: "Solver Takeover Chances: ", title: "solverTakeoverChances"}, {gap: true},
			{text: "Easy Piece", title: "solverTakeoverChancesEasyPiece"}, {numInput: {arrPath: ["solverTakeoverChances","easyPiece"], isPercentage: true}}, {gap: true},
			{text: "Hard Piece", title: "solverTakeoverChancesHardPiece"}, {numInput: {arrPath: ["solverTakeoverChances","hardPiece"], isPercentage: true}}, {gap: true},
			{text: "Cursed Piece", title: "solverTakeoverChancesCursedPiece"}, {numInput: {arrPath: ["solverTakeoverChances","cursedPiece"], isPercentage: true}}
		],
		[
			{text: "Solver Delay", title: "solverTimer"}, {numInput: {arrPath: ["solverTimer","max"]}}, {text: "frames"}
		],
		[],
		[
			{text: "Multiple-Choice Chance:", title: "multipleChoiceChance"}, {numInput: {arrPath: ["multipleChoiceChance"], isPercentage: true}}, {gap: true},
			{text: "Order Multiple-Choice", title: "isMultipleChoiceOrdered"}, {checkBox: {arrPath: ["isMultipleChoiceOrdered"]}}
		],
		[
			{text: "Teleport Movement", title: "teleportMovement"}, {checkBox: {arrPath: ["teleportMovement"]}}
		],
	];
	
	function generateMenu(){
		isInRebindControls = false;
		selectedRebindButton = "";
		
		let text = '';
		
		text += '<br><br><button onclick="startButtonClick()">Start Cursetris</button><br><br>';
		
		text += "Presets: ";
		
		let presetNum = 0;
		for (let i in rulesPresets){
			text += '<button onclick="rulesPresetsClick(\'' + i + '\')">' + i + '</button> ';
			
			presetNum++;
			if (presetNum % 5 == 0){
				text += '<br>';
			}
		}
		
		text += '<br><br>';
		
		
		if (specialPieceDescriptions[specialPieceNames[rules.startingPieceNums[0]]] != undefined){
			text += 'Starting Piece: ' + specialPieceDescriptions[specialPieceNames[rules.startingPieceNums[0]]];
			text += ' <button onclick="removeStartingPiece()">Remove</button>'
		}
		
		text += '<br><br>';
		
		for (let i in menuTexts){
			for (let arr of menuTexts[i]){
				if (arr.text != undefined){
					if (menuExplanations[arr.title] != undefined){
						text += '<label title="' + menuExplanations[arr.title] + '" style="border-bottom: 0.05vw dotted white;">' + arr.text + '</label>'
					} else{
						text += arr.text;
					}
					
					text += " ";
				}
				
				if (arr.numInput != undefined){
					text += '<input type="number" min="0"';
					
					text += (arr.numInput.isPercentage) ? 'max="100" step="0.1" ' : 'step="1"';
					
					
					let num = getRuleValueFromArrPath(arr.numInput.arrPath);
					num *= (arr.numInput.isPercentage) ? 100 : 1;
					
					text += 'value="' + num + '"';
					
					
					let id = arr.numInput.arrPath.toString().replaceAll(',', '');
					
					text += 'id="' + id + '"';
					
					text += 'onchange="onMenuInputChange(\'' + id + '\', ' + arr.numInput.isPercentage + ', ' + arr.numInput.canGoOver100 + ')"';
					
					text += '></input>';
					
					text += (arr.numInput.isPercentage) ? '%' : '';
				}
				
				if (arr.checkBox != undefined){
					text += '<input type="checkbox"';
					
					let isChecked = getRuleValueFromArrPath(arr.checkBox.arrPath);
					
					text += (isChecked) ? 'checked' : '';
					
					
					let id = arr.checkBox.arrPath.toString().replaceAll(",", "");
					
					text += ' id="' + id + '"';
					
					text += '></input>';
					
					text += '&emsp;'.repeat(5);
				}
				
				if (arr.button != undefined){
					let onclickText = (arr.button.onclick != undefined) ? "onclick='" + arr.button.onclick + "'" : "";
					
					text += '<button ' + onclickText + '>';
					
					text += arr.button.text;
					
					text += '</button>';
					
					text += '&emsp;'.repeat(5);
				}
				
				if (arr.gap){
					text += '&emsp;'.repeat(5);
				}
			}
			
			text += '<br><br>';
		}
		
		text += '<br>Made by <a href="https://www.youtube.com/@Soverthe">Sover the</a>'
		
		document.getElementById("menuDiv").innerHTML = text;
	}
	
	
	function selectRebindButton(type){
		selectedRebindButton = (selectedRebindButton != type) ? type : "";
		
		generateRebindControlsMenu();
	}
	
	function removeInputButtons(type){
		inputButtons[type].keyboard = [];
		
		generateRebindControlsMenu();
	}
	
	function resetInputButtons(type){
		inputButtons[type].keyboard = structuredClone(defaultInputButtons[type].keyboard);
		
		generateRebindControlsMenu();
	}
	
	function generateRebindControlsMenu(){
		isInRebindControls = true;
		
		let text = '<div style="text-align: left; margin-left: 20vw;">';
		
		text += '<br><br><br><br>';
		
		
		for (let arr of inputButtonRebindLayout){
			text += arr.text;
			
			text += "<br><br><br><br>";
			
			for (let button of arr.buttons){
				let styleText = (selectedRebindButton == button.type) ? 'style="background-color:#8811ff"' : '';
				
				text += '<button onclick="selectRebindButton(\'' + button.type + '\')" ' + styleText + '>' + button.text + ':</button> ';
				
				text += inputButtons[button.type].keyboard.join(", ").replaceAll("Key","").replaceAll("Arrow","").replaceAll("Digit","");
				
				text += ' <button onclick="removeInputButtons(\'' + button.type + '\')">Remove All</button>';
				text += '<button onclick="resetInputButtons(\'' + button.type + '\')">Reset</button>';
				
				text += "<br><br>";
			}
			
			text += "<br><br>";
		}
		
		text += (selectedRebindButton != "") ? "Press any button on your keyboard to add/remove it" : "";
		
		text += "<br><br><br><br>";
		
		text += '<button onclick="generateMenu()">Back</button>';
		
		text += '</div>';
		
		document.getElementById("menuDiv").innerHTML = text;
	}
	
	
	
	function changeRulesByMenu(){
		for (let i in menuTexts){
			for (let arr of menuTexts[i]){
				let value = 0;
				
				let arrPath;
				
				if (arr.numInput != undefined){
					arrPath = arr.numInput.arrPath;
					
					let id = arrPath.toString().replaceAll(',', '');
					
					value = Number(document.getElementById(id).value);
					
					if (arr.numInput.isPercentage){
						value /= 100;
					}
				}
				
				if (arr.checkBox != undefined){
					arrPath = arr.checkBox.arrPath;
					
					let id = arrPath.toString().replaceAll(",", "");
					
					value = document.getElementById(id).checked;
				}
				
				if (arrPath != undefined){
					let pathText = "rules";
					
					for (let i in arrPath){
						pathText += "['" + arrPath[i] + "']";
					}
					
					eval(pathText + "=" + value);
				}
			}
		}
	}
	
	function startButtonClick(){
		changeRulesByMenu();
		
		document.getElementById("menuDiv").style.display = "none";
		document.getElementById("gameDiv").style.display = "inline-block";
		document.body.overflow = "hidden";
		
		generateEmptyBoard();
		
		generateInitialPiece();
		
		currentLevel = 0;
		lineClearNums = {horizontal: 0, vertical: 0};
		previousScoreNum = 0;
		
		
		for (let i in inputButtons){
			inputButtons[i].timer = 0;
		}
		shouldDrawControls = (JSON.stringify(inputButtons) == JSON.stringify(defaultInputButtons));
		
		
		currentFallingSpeed = rules.movementTimer.max.y;
		
		
		shouldPauseNextFrame = false;
		
		nextFrame();
	}
	
	function returnToMenu(){
		generateMenu();
		
		document.getElementById("menuDiv").style.display = "inline-block";
		document.getElementById("gameDiv").style.display = "none";
		document.body.overflow = "auto";
		
		shouldPauseNextFrame = true;
	}
	
</script>

<script> //General
	
	let t = 0;
	function slowLog(text){ //so console.log won't stop the browser
		if (t % Math.floor(fps/2) == 0){
			console.log(text);
		}
	}
	
	
	function getNumInRange(num, min, max, type){ //could be more clever
		if (type == "loop"){
			if (num < min){ num = max; }
			if (num > max){ num = min; }
		} else{
			if (num < min){ num = min; }
			if (num > max){ num = max; }
		}
		
		return num;
	}
	
	function range(size){ //example: for (let i of range(10))
		return [...Array(size).keys()];
	}
	
	
	function getRandomNum(min, max){
		return Math.floor(Math.random() * (max - min + 1) + min);
	}
	
	
	function toggleWindowBoolean(name){
		window[name] = !window[name];
	}
	
	
	function sortObjectByValue(arr, valueName, isSmallToBig){ //https://stackoverflow.com/a/1063027/1277794
		if (isSmallToBig){
			arr.sort((a,b) => a[valueName] - b[valueName]);
		} else{
			arr.sort((a,b) => b[valueName] - a[valueName]);
		}
	}
	
	function sortObjectBy2DValue(arr, valueName1, valueName2, isSmallToBig){
		if (isSmallToBig){
			arr.sort((a,b) => a[valueName1][valueName2] - b[valueName1][valueName2]);
		} else{
			arr.sort((a,b) => b[valueName1][valueName2] - a[valueName1][valueName2]);
		}
	}
	
	
	function getAverageOfArray(arr){
		return arr.reduce((a, b) => a + b) / arr.length;
	}
	
	
	function getCurrentTime(){
		return new Date().getTime();
	}
	
	
	function copyTextToClipboard(text){
		navigator.clipboard.writeText(text);
	}
	
	
	function getPosInArr(pos, arr){
		let value;
		
		if (arr[pos.y] != undefined){
			if (arr[pos.y][pos.x] != undefined){
				value = arr[pos.y][pos.x];
			}
		}
		return value;
	}
	
	function isPosInArr(pos, arr){
		let isInArr = false;
		
		if (arr[pos.y] != undefined){
			if (arr[pos.y][pos.x] != undefined){
				isInArr = true;
			}
		}
		return isInArr;
	}
	
	function setValueInArrAtPos(value, arr, pos){
		if (arr[pos.y] == undefined){
			arr[pos.y] = [];
		}
		
		arr[pos.y][pos.x] = value;
		
		return arr;
	}
	
</script>

<script> //General Board Functions
	
	function generateEmptyBoard(){
		board = [];
		
		for (let i of range(boardData.h)){
			board[i] = [];
			
			for (let j of range(boardData.w)){
				board[i][j] = {num: 0};
			}
		}
		
		
		tallerBoard = structuredClone(board);
		
		for (let i = -1; i > -6; i--){
			tallerBoard[i] = [];
			
			for (let j of range(boardData.w)){
				tallerBoard[i][j] = {num: 0};
			}
		}
	}
	
	
	function clearHorizontalFullLines(currentBoard, disableScoreIncrement){
		let fullLines = [];
		
		for (let i = 0; i < currentBoard.length; i++){
			let isLineFull = true;
			let isLineFallen;
			
			for (let j = 0; j < currentBoard[i].length; j++){
				if (currentBoard[i][j].num == 0){
					isLineFull = false;
				}
				
				
				let hasFallen = (currentBoard[i][j].hasFallen == true);
				
				if (isLineFallen == undefined){
					isLineFallen = hasFallen;
				}
				
				if (hasFallen != isLineFallen){
					isLineFull = false;
				}
			}
			
			if (isLineFull){
				fullLines[i] = true;
			}
		}
		
		
		let consecutiveNum = rules.minConsecutiveLineClears;
		
		let previousShouldClear = false;
		
		for (let i = 0; i < currentBoard.length; i++){
			let shouldClear = fullLines[i];
			
			if (consecutiveNum > 1){
				if (!previousShouldClear){
					
					let isConsecutiveFull = true;
					
					for (let k = i + 1; k < i + consecutiveNum; k++){
						if (!fullLines[k]){
							isConsecutiveFull = false;
						}
					}
					
					if (!isConsecutiveFull){
						shouldClear = false;
					}
				}
			}
			
			if (shouldClear){
				for (let reverseI = i; reverseI > 0; reverseI--){
					currentBoard[reverseI] = structuredClone(currentBoard[reverseI - 1]);
				}
				
				currentBoard[0] = [];
				for (let j of range(boardData.w)){
					currentBoard[0][j] = {num: 0};
				}
				
				if (!disableScoreIncrement){
					lineClearNums.horizontal++;
				}
			}
			
			previousShouldClear = shouldClear;
		}
	}
	
	function clearVerticalFullLines(currentBoard, disableScoreIncrement){
		let fullLines = [];
		for (let j = currentBoard[0].length - 1; j >= 0; j--){
			let isLineFull = true;
			let isLineFallen;
			
			for (let i = currentBoard.length - rules.verticalLineHeight; i < currentBoard.length; i++){
				if (currentBoard[i][j].num == 0){
					isLineFull = false;
				}
				
				
				let hasFallen = (currentBoard[i][j].hasFallen == true);
				
				if (isLineFallen == undefined){
					isLineFallen = hasFallen;
				}
				
				if (hasFallen != isLineFallen){
					isLineFull = false;
				}
			}
			
			if (isLineFull){
				fullLines[j] = true;
			}
		}
		
		let consecutiveNum = rules.minConsecutiveLineClears;
		
		let previousShouldClear = false;
		
		for (let j = currentBoard[0].length - 1; j >= 0; j--){
			let shouldClear = fullLines[j];
			
			if (consecutiveNum > 1){
				if (!previousShouldClear){
					
					let isConsecutiveFull = true;
					
					if (j > 4){
						for (let k = j - 1; k > j - consecutiveNum; k--){
							if (!fullLines[k]){
								isConsecutiveFull = false;
							}
						}
					} else{
						for (let k = j + 1; k < j + consecutiveNum; k++){
							if (!fullLines[k]){
								isConsecutiveFull = false;
							}
						}
					}
					
					if (!isConsecutiveFull){
						shouldClear = false;
					}
				}
			}
			
			if (shouldClear){
				
				fullLines[j] = false;
				
				if (j > 4){
					for (let i in currentBoard){
						for (let k = j; k > 0; k--){
							currentBoard[i][k] = currentBoard[i][k - 1];
						}
					}
					
					for (let i in currentBoard){
						currentBoard[i][0] = {num: 0};
					}
					
					fullLines.splice(j, 1);
					
					fullLines.splice(0, 0, false);
				} else{
					for (let i in currentBoard){
						for (let k = j; k + 1 < currentBoard[i].length; k++){
							currentBoard[i][k] = currentBoard[i][k + 1];
						}
					}
					
					for (let i in currentBoard){
						currentBoard[i][currentBoard[i].length - 1] = {num: 0};
					}
					
					fullLines.splice(j, 1);
				}
				
				if (!disableScoreIncrement){
					lineClearNums.vertical++;
				}
				
				j++;
			}
			
			previousShouldClear = shouldClear;
		}
	}
	
	
	function clearFullLines(currentBoard, disableScoreIncrement){
		if (rules.clearVertical){
			clearVerticalFullLines(currentBoard, disableScoreIncrement);
		}
		if (rules.clearHorizontal){
			clearHorizontalFullLines(currentBoard, disableScoreIncrement);
		}
		
		if (!disableScoreIncrement){
			let overallScore = lineClearNums.horizontal + lineClearNums.vertical;
			
			currentLevel = Math.floor(overallScore / lineClearsPerLevel) % levelColors.length;
		}
	}
	
	function getBoardWithoutFullLines(currentBoardArr, disableScoreIncrement){
		let currentBoard = structuredClone(currentBoardArr);
		
		clearFullLines(currentBoard, disableScoreIncrement);
		
		return currentBoard;
	}
	
	
	function isBoardEmpty(){
		let isEmpty = true;
		
		for (let i in board){
			for (let j in board[i]){
				if (board[i][j].num != 0){
					isEmpty = false;
				}
			}
		}
		return isEmpty;
	}
	
	
</script>

<script> //Cursed Pieces Chance
	
	function getCursedPiecesChance(){
		let chance = rules.cursedPiecesChance;
		
		let holesNum = getHolesNumInBoard(board);
		
		for (let i in range(holesNum)){
			chance *= rules.cursedPiecesChanceMultiplierPerHole;
		}
		
		chance = Math.min(chance, 1);
		
		return chance;
	}
	
</script>
<script> //Next Piece
	
	function getPieceType(pieceNum){
		return (pieceNum < 4) ? "easyPiece" : ((pieceNum < 7) ? "hardPiece" : "cursedPiece");
	}
	
	function setPieceOnBoard(currentBoard, x, y, rotationNum, pieceNum){
		let pieceArr = pieces[pieceNum][rotationNum];
		
		for (let i = 0; i < pieceArr.length; i++){
			for (let j = 0; j < pieceArr[i].length; j++){
				if (pieceArr[i][j] != 0){
					let pos = {
						x: x + (j - Math.floor(pieceArr[i].length/2)),
						y: y + (i - Math.floor(pieceArr.length/2))
					}
					
					if (isPosInArr(pos, currentBoard)){
						setValueInArrAtPos({num: (pieceColorsNums[pieceNum] ?? 0) + 1}, currentBoard, pos);
					}
				}
			}
		}
	}
	
	function setCurrentPieceOnBoard(){
		setPieceOnBoard(board, currentPiece.x, currentPiece.y, currentPiece.rotationNum, currentPiece.pieceNum);
		
		clearFullLines(board);
	}
	
	
	function generateNextPieceNums(){
		for (let i = nextPieceNums.length; i < Math.max(rules.nextPieceDepth, 1); i++){
			nextPieceNums[i] = getRandomNum(0, 6);
			
			if (rules.noEasyPieces){
				nextPieceNums[i] = getRandomNum(4, 6);
			}
			
			if (rules.noHardPieces){
				nextPieceNums[i] = getRandomNum(0, 3);
			}
			
			if (getCursedPiecesChance() > Math.random() || (rules.noEasyPieces && rules.noHardPieces)){
				nextPieceNums[i] = getRandomNum(cursedPieces.min, cursedPieces.max);
			}
		}
	}
	
	
	function nextPiece(isPieceless){
		let isGameOver = false;
		
		if (!isPieceless){
			previousScoreNum = lineClearNums.vertical + lineClearNums.horizontal;
			
			setCurrentPieceOnBoard();
		}
		
		if (!isBoardEmpty()){
			if (currentPiece.x == currentPiece.startingPos.x && currentPiece.y == currentPiece.startingPos.y){
				if ((lineClearNums.vertical + lineClearNums.horizontal) == previousScoreNum){
					isGameOver = true;
				}
			}
		}
		
		if (!isGameOver){
			currentPiece.pieceNum = nextPieceNums[0];
			
			nextPieceNums.shift();
			
			generateNextPieceNums();
			
			currentPiece.x = 5;
			currentPiece.y = pieceStartingY[currentPiece.pieceNum] ?? 0;
			currentPiece.rotationNum = 0;
			rules.movementTimer.x = rules.movementTimer.max.x;
			rules.movementTimer.y = currentFallingSpeed * 2;
			currentPiece.hasReleasedDown = false;
			
			currentPiece.startingPos = {x: currentPiece.x, y: currentPiece.y};
			
			isCurrentlyMultipleChoice = false;
			
			if (rules.solverTakeoverChances[getPieceType(currentPiece.pieceNum)] > Math.random()){
				rules.solverTimer.num = rules.solverTimer.max;
				
				if (rules.solverTimer.num == 0){
					setCurrentPieceOnBestLocation();
				}
			} else{
				if (rules.multipleChoiceChance > Math.random()){
					isCurrentlyMultipleChoice = true;
					
					refreshMultipleChoiceChoices();
				}
			}
		} else{
			shouldPauseNextFrame = true;
			
			setTimeout(returnToMenu, 333);
		}
	}
	
	function generateInitialPiece(){
		nextPieceNums = [];
		
		for (let i in rules.startingPieceNums){
			if (pieces[rules.startingPieceNums[i]] != undefined){
				nextPieceNums[i] = rules.startingPieceNums[i];
			}
		}
		
		generateNextPieceNums();
		
		nextPiece(true);
	}
	
</script>

<script> //General Hitbox Functions
	
	function isVertexInRect(v, r){
		return (v.x >= r.x && v.x <= r.x + r.w &&
				v.y >= r.y && v.y <= r.y + r.h);
	}
	
	
	function getVertexDistance(v1, v2){
		return Math.sqrt(Math.abs(v1.x - v2.x) ** 2 + Math.abs(v1.y - v2.y) ** 2);
	}
	
	function getVertexToRectDistance(v, r){ //https://stackoverflow.com/a/41286161
		let b = {left: r.x, right: r.x + r.w, top: r.y, bottom: r.y + r.h};
		
		let d = {x: 0, y: 0};
		
		if (v.x < b.left){
			d.x = b.left - v.x;
		} else if (v.x > b.right){
			d.x = b.right - v.x;
		}
		
		if (v.y < b.top){
			d.y = b.top - v.y;
		} else if (v.y > b.bottom){
			d.y = b.bottom - v.y;
		}
		
		return Math.sqrt(d.x ** 2 + d.y ** 2);
	}
	
	
	function getVertexToVertexRadians(v1, v2){
		let deltaX = v2.x - v1.x; 
		let deltaY = v2.y - v1.y;
		
		return Math.atan2(deltaY, deltaX);
	}
	
	function getVertexToVertexDirection(v1, v2){
		let radians = getVertexToVertexRadians(v1, v2);
		
		return {x: Math.cos(radians), y: Math.sin(radians)};
	}
	
</script>
<script> //Piece Hitbox
	
	function isPiecePositionValid(x, y, rotationNum, pieceNum){
		let isValid = true;
		
		let pieceArr = pieces[pieceNum][rotationNum];
		
		for (let i = 0; i < pieceArr.length; i++){
			for (let j = 0; j < pieceArr[i].length; j++){
				if (pieceArr[i][j] != 0){
					let pos = {
						x: x + (j - Math.floor(pieceArr[i].length/2)),
						y: y + (i - Math.floor(pieceArr.length/2))
					}
					
					if (!isPosInArr(pos, tallerBoard)){
						isValid = false;
					}
					
					if (isPosInArr(pos, board)){
						if (board[pos.y][pos.x].num != 0){
							isValid = false;
						}
					}
				}
			}
		}
		return isValid;
	}
	
	function isCurrentPiecePositionValid(){
		return isPiecePositionValid(currentPiece.x, currentPiece.y, currentPiece.rotationNum, currentPiece.pieceNum);
	}
	
	
	function arePiecesTouching(p1, p2){ //not the quickest way to do this but hey
		
		let p1PieceArr = pieces[p1.pieceNum ?? currentPiece.pieceNum][p1.rotationNum];
		let p2PieceArr = pieces[p2.pieceNum ?? currentPiece.pieceNum][p2.rotationNum];
		
		let isTouching = false;
		
		for (let i = 0; i < p1PieceArr.length; i++){
			for (let j = 0; j < p1PieceArr[i].length; j++){
				if (p1PieceArr[i][j] != 0){
					
					let pos = {
						x: p1.x + (j - Math.floor(p1PieceArr[i].length/2)),
						y: p1.y + (i - Math.floor(p1PieceArr.length/2))
					}
					
					
					for (let i2 = 0; i2 < p2PieceArr.length; i2++){
						for (let j2 = 0; j2 < p2PieceArr[i2].length; j2++){
							if (p2PieceArr[i2][j2] != 0){
								
								let pos2 = {
									x: p2.x + (j2 - Math.floor(p2PieceArr[i2].length/2)),
									y: p2.y + (i2 - Math.floor(p2PieceArr.length/2))
								}
								
								
								if (pos.x == pos2.x){
									if (Math.abs(pos.y - pos2.y) <= 1){
										isTouching = true;
									}
								} else if (pos.y == pos2.y){
									if (Math.abs(pos.x - pos2.x) <= 1){
										isTouching = true;
									}
								}
								
							}
						}
					}
					
					
				}
			}
		}
		return isTouching;
		console.log(p1, p2);
	}
	
</script>

<script> //Keyboard/Gamepad Axis Inputs
	
	function getKeyboardMovementAxes(axes){
		for (let xy of xyArr){
		
			for (let key of keyboardAxes[xy].negative){
				if (inputs[key]){
					axes[xy] = -1;
				}
			}
			
			for (let key of keyboardAxes[xy].positive){
				if (inputs[key]){
					axes[xy] = 1;
				}
			}
		}
		return axes;
	}
	
	function getGamepadDpadAxes(axes){
		for (let gamepad of gamepads){
			if (gamepad != null){
				for (let xy of xyArr){
					for (let key of gamepadDpadAxes[xy].negative){
						if (gamepad.buttons[key] != undefined){
							if (gamepad.buttons[key].pressed){
								axes[xy] = -1;
							}
						}
					}
					
					for (let key of gamepadDpadAxes[xy].positive){
						if (gamepad.buttons[key] != undefined){
							if (gamepad.buttons[key].pressed){
								axes[xy] = 1;
							}
						}
					}
				}
			}
		}
		return axes;
	}
	
	function getGamepadMovementAxes(axes){
		for (let gamepad of gamepads){
			if (gamepad != null){
				
				let directionSigns = {
					x: ((gamepad.axes[0] < 0) ? -1 : 1),
					y: ((gamepad.axes[1] < 0) ? -1 : 1)
				}
				
				let speeds = {
					x: Math.abs(gamepad.axes[0]) - gamepadAxisRange.min,
					y: Math.abs(gamepad.axes[1]) - gamepadAxisRange.min
				}
				
				let maxSpeed = (gamepadAxisRange.max - gamepadAxisRange.min);
				
				for (let xy of xyArr){
					if (speeds[xy] > maxSpeed){ speeds[xy] = maxSpeed; }
					
					if (speeds[xy] > 0){
						axes[xy] = (1 / maxSpeed) * speeds[xy] * directionSigns[xy];
					}
				}
			}
		}
		return axes;
	}
	
</script>
<script> //Keyboard/Gamepad Button Inputs
	
	function refreshButtonPressStates(){
		inputButtonStates = {};
		
		for (let buttonName in inputButtons){
			let button = inputButtons[buttonName];
			
			
			let isConditionFulfilled = true;
			
			if (button.condition != undefined){
				let value = window[button.condition.arrPath[0]];
				
				for (let i = 1; i < button.condition.arrPath.length; i++){
					value = value[button.condition.arrPath[1]];
				}
				
				isConditionFulfilled = value == button.condition.target;
			}
			
			
			if (isConditionFulfilled){
				let isPressed = false;
				
				let pressedNum = 0;
				
				for (let i in button.keyboard){
					if (inputs[button.keyboard[i]]){
						isPressed = true;
						pressedNum = i;
					}
				}
				
				for (let gamepadNum in button.gamepads){
					let gamepad = gamepads[gamepadNum];
					
					if (gamepad != null){
						
						for (let i in button.gamepads[gamepadNum]){
							if (gamepad.buttons[button.gamepads[gamepadNum][i]] != undefined){
								if (gamepad.buttons[button.gamepads[gamepadNum][i]].pressed){
									isPressed = true;
									pressedNum = i;
								}
							}
						}
					}
				}
				
				let isDelayed = false;
				
				if (button.timer > 0){
					if (isPressed){
						isDelayed = true;
						
						button.timer--;
					} else{
						button.timer = 0;
					}
				}
				
				if (!isDelayed && isPressed){
					inputButtonStates[buttonName] = true;
					
					if (button.maxTimer > 0){
						button.timer = button.maxTimer;
					}
				} else{
					inputButtonStates[buttonName] = false;
				}
				
				if (inputButtonStates[buttonName]){
					if (window[button.functionName] != undefined){
						let args = button.functionArgs;
						
						if (args == "pressedNum"){
							args = pressedNum;
						}
						
						window[button.functionName](args);
					}
				}
			}
		}
	}
	
</script>
<script> //Piece and Block Movement
	
	function dropCurrentPiece(){
		if (currentPiece.hasReleasedDown){
			currentPiece.y++;
			
			if (!isCurrentPiecePositionValid()){
				currentPiece.y--;
				
				nextPiece();
			}
		}
	}
	
	function moveCurrentPiece(){
		
		let movementAxes = {x: 0, y: 0};
		
		movementAxes = getKeyboardMovementAxes(movementAxes);
		movementAxes = getGamepadDpadAxes(movementAxes);
		movementAxes = getGamepadMovementAxes(movementAxes);
		
		
		if (rules.movementTimer.x > 0){
			rules.movementTimer.x--;
		}
		if (rules.movementTimer.y > 0){
			rules.movementTimer.y--;
		}
		
		
		
		if (!rules.teleportMovement){
			if (movementAxes.x != 0){
				if (rules.movementTimer.x == 0){
					currentPiece.x += (movementAxes.x < 0) ? -1 : 1;
					
					if (!isCurrentPiecePositionValid()){
						currentPiece.x -= (movementAxes.x < 0) ? -1 : 1;
					}
					
					rules.movementTimer.x = rules.movementTimer.max.x;
				}
			} else{
				rules.movementTimer.x = 0;
			}
		}
		
		if ((movementAxes.y > 0 && !rules.teleportMovement)){
			dropCurrentPiece();
		} else{
			currentPiece.hasReleasedDown = true;
		}
		
		if (rules.movementTimer.y <= 0){
			currentPiece.y++;
			
			if (!isCurrentPiecePositionValid()){
				currentPiece.y--;
				
				nextPiece();
			}
			
			currentFallingSpeed = rules.movementTimer.max.y;
			
			let overallScore = lineClearNums.horizontal + lineClearNums.vertical;
			
			for (let i = 0; i < overallScore; i++){
				currentFallingSpeed *= rules.fallingSpeedMultiplierPerClear;
			}
			
			rules.movementTimer.y = currentFallingSpeed;
		}
	}
	
	function moveTeleportMovementPiece(pressedNum){
		let i = Number(pressedNum);
		
		let previousX = currentPiece.x;
		
		currentPiece.x = i;
		
		if (!isCurrentPiecePositionValid()){
			currentPiece.x = previousX;
			
			if (i != currentPiece.x){
				let increment = (i > currentPiece.x) ? -1 : 1;
				
				for (let j = i + increment; j != previousX; j += increment){ //if this ever goes on forever I'll cry
					currentPiece.x = j;
					
					if (isCurrentPiecePositionValid()){
						j = previousX - increment;
					} else{
						currentPiece.x = previousX;
					}
				}
			}
		}
	}
	
	
	
	function gravityNextFrame(){
		let nextBoard = structuredClone(board);
		
		let didBoardChange = false;
		
		for (let i = 0; i < board.length - 1; i++){
			for (let j = 0; j < board[i].length; j++){
				if (board[i][j].num != 0 && board[i + 1][j].num == 0){
					
					nextBoard[i + 1][j].num = nextBoard[i][j].num;
					nextBoard[i + 1][j].hasFallen = true;
					
					nextBoard[i][j] = {num: 0};
					
					didBoardChange = true;
				}
			}
		}
		
		board = nextBoard;
		
		if (didBoardChange){
			clearFullLines(board);
			
			refreshMultipleChoiceChoices();
		}
	}
	
</script>
<script> //Piece Rotation
	
	function onRotateLeft(isTeleportRotate, isInvertedCall){
		if (rules.invertedRotation && !isInvertedCall){
			onRotateRight(isTeleportRotate, true);
		} else{
			if (!rules.teleportMovement || isTeleportRotate){
				let previousRotationNum = currentPiece.rotationNum;
				
				currentPiece.rotationNum--;
				
				if (currentPiece.rotationNum < 0){
					currentPiece.rotationNum = pieces[currentPiece.pieceNum].length - 1;
				}
				
				if (!isCurrentPiecePositionValid()){
					currentPiece.rotationNum = previousRotationNum;
				}
			}
		}
	}
	
	function onRotateRight(isTeleportRotate, isInvertedCall){
		if (rules.invertedRotation && !isInvertedCall){
			onRotateLeft(isTeleportRotate, true);
		} else{
			if (!rules.teleportMovement || isTeleportRotate){
				let previousRotationNum = currentPiece.rotationNum;
				
				currentPiece.rotationNum++;
				
				if (currentPiece.rotationNum > pieces[currentPiece.pieceNum].length - 1){
					currentPiece.rotationNum = 0;
				}
				
				if (!isCurrentPiecePositionValid()){
					currentPiece.rotationNum = previousRotationNum;
				}
			}
		}
	}
	
</script>

<script> //Board Score
	
	function getHolesNumInBoard(currentBoard){
		let holesNum = 0;
		
		for (let x in currentBoard[0]){
			let hitPiece = false;
			
			for (let y in currentBoard){
				if (currentBoard[y][x].num != 0){
					hitPiece = true;
				} else{
					if (hitPiece){
						holesNum++;
					}
				}
			}
		}
		return holesNum;
	}
	
	function getEnclosedHolesNumInBoard(currentBoard){
		let holesNum = 0;
		
		for (let x in currentBoard[0]){
			let hitPiece = false;
			
			for (let y in currentBoard){
				if (currentBoard[y][x].num != 0){
					hitPiece = true;
				} else{
					if (hitPiece){
						if (getPosInArr({x: x - 1, y: y}, currentBoard) != 0 && getPosInArr({x: x + 1, y: y}, currentBoard) != 0){
							holesNum++;
						}
					}
				}
			}
		}
		return holesNum;
	}
	
	function getBoardHeight(currentBoard){
		let height = 0;
		
		for (let i = 0; i < currentBoard.length; i++){
			for (let j in currentBoard[i]){
				if (currentBoard[i][j].num != 0){
					height = currentBoard.length - i;
					
					i = currentBoard.length;
					break;
				}
			}
		}
		return height;
	}
	
	function getBoardElevation(currentBoard){
		let heightArr = [];
		
		for (let j in currentBoard[0]){
			heightArr[j] = 0;
			
			for (let i = 0; i < currentBoard.length; i++){
				if (currentBoard[i][j].num != 0){
					heightArr[j] = currentBoard.length - i;
					
					i = currentBoard.length;
				}
			}
		}
		
		let elevationNum = 0;
		let previousHeightNum = 0;
		for (let i in heightArr){
			if (i != 0){
				elevationNum += Math.abs(heightArr[i] - previousHeightNum);
			}
			
			previousHeightNum = heightArr[i];
		}
		
		return elevationNum;
	}
	
	function getBoardDangerScore(currentBoardArr){
		let previousBoardHeight = getBoardHeight(currentBoardArr);
		
		let currentBoard = getBoardWithoutFullLines(currentBoardArr, true);
		
		let holesNum = getHolesNumInBoard(currentBoard);
		let enclosedHolesNum = getEnclosedHolesNumInBoard(currentBoard);
		
		let boardHeight = getBoardHeight(currentBoard);
		
		let boardElevation = getBoardElevation(currentBoard);
		
		
		let boardHeightChange = (previousBoardHeight - boardHeight + 1);
		if (boardHeightChange < 1){ boardHeightChange = 1; }
		boardHeightChange = 1 / boardHeightChange;
		
		//todo: created holes that should be penalized a lot
		//		don't stack onto holes
		
		return (boardElevation*0.5+1) * (holesNum**1.1+1) * (enclosedHolesNum**1.1+1) * (boardHeight+1) * (boardHeightChange);
	}
	
</script>
<script> //Solver
	
	function getPossiblePieceLocations(){
		let centerArr = [];
		let droppedPositions = [];
		
		for (let i in board){
			centerArr[i] = [];
			for (let j in board[i]){
				centerArr[i][j] = [];
			}
		}
		
		centerArr[currentPiece.y][currentPiece.x][currentPiece.rotationNum] = true;
		
		
		let maxRotations = pieces[currentPiece.pieceNum].length;
		
		let possibilities = [{x: currentPiece.x, y: currentPiece.y, rotationNum: currentPiece.rotationNum}];
		
		
		while (possibilities.length > 0){
			//rotate left
			for (let i = 1; i < maxRotations; i++){
				let rotationNum = possibilities[0].rotationNum - i;
				
				if (rotationNum < 0){ rotationNum += maxRotations; }
				
				
				if (isPiecePositionValid(possibilities[0].x, possibilities[0].y, rotationNum, currentPiece.pieceNum)){
					if (!centerArr[possibilities[0].y][possibilities[0].x][rotationNum]){
						centerArr[possibilities[0].y][possibilities[0].x][rotationNum] = true;
						
						possibilities.push({x: possibilities[0].x, y: possibilities[0].y, rotationNum: rotationNum});
					}
				} else{
					i = maxRotations;
				}
				
			}
			//rotate right
			for (let i = 1; i < maxRotations; i++){
				let rotationNum = possibilities[0].rotationNum + i;
				
				if (rotationNum >= maxRotations){ rotationNum -= maxRotations; }
				
				
				if (isPiecePositionValid(possibilities[0].x, possibilities[0].y, rotationNum, currentPiece.pieceNum)){
					if (!centerArr[possibilities[0].y][possibilities[0].x][rotationNum]){
						centerArr[possibilities[0].y][possibilities[0].x][rotationNum] = true;
						
						possibilities.push({x: possibilities[0].x, y: possibilities[0].y, rotationNum: rotationNum});
					}
				} else{
					i = maxRotations;
				}
				
			}
			
			//move left
			for (let i = possibilities[0].x - 1; i >= 0; i--){
				if (isPiecePositionValid(i, possibilities[0].y, possibilities[0].rotationNum, currentPiece.pieceNum)){
					if (!centerArr[possibilities[0].y][i][possibilities[0].rotationNum]){
						centerArr[possibilities[0].y][i][possibilities[0].rotationNum] = true;
						
						possibilities.push({x: i, y: possibilities[0].y, rotationNum: possibilities[0].rotationNum});
					}
				} else{
					i = -1;
				}
			}
			//move right
			for (let i = possibilities[0].x + 1; i < board[0].length; i++){
				if (isPiecePositionValid(i, possibilities[0].y, possibilities[0].rotationNum, currentPiece.pieceNum)){
					if (!centerArr[possibilities[0].y][i][possibilities[0].rotationNum]){
						centerArr[possibilities[0].y][i][possibilities[0].rotationNum] = true;
						
						possibilities.push({x: i, y: possibilities[0].y, rotationNum: possibilities[0].rotationNum});
					}
				} else{
					i = board[0].length;
				}
			}
			
			
			//move down
			if (isPiecePositionValid(possibilities[0].x, possibilities[0].y + 1, possibilities[0].rotationNum, currentPiece.pieceNum)){
				if (!centerArr[possibilities[0].y + 1][possibilities[0].x][possibilities[0].rotationNum]){
					centerArr[possibilities[0].y + 1][possibilities[0].x][possibilities[0].rotationNum] = true;
					
					possibilities.push({x: possibilities[0].x, y: possibilities[0].y + 1, rotationNum: possibilities[0].rotationNum});
				}
			} else{
				droppedPositions.push({x: possibilities[0].x, y: possibilities[0].y, rotationNum: possibilities[0].rotationNum});
			}
			
			possibilities.shift();
		}
		
		return droppedPositions;
	}
	
	function getBoardWithPiece(currentBoard, x, y, rotationNum, pieceNum){
		let boardArr = structuredClone(currentBoard);
		
		setPieceOnBoard(boardArr, x, y, rotationNum, pieceNum);
		
		return boardArr;
	}
	
	
	function getPossiblePieceLocationRanks(){
		let possibilities = getPossiblePieceLocations();
		
		let scoreArr = [];
		
		for (let i in possibilities){
			let currentBoard = getBoardWithPiece(board, possibilities[i].x, possibilities[i].y, possibilities[i].rotationNum, currentPiece.pieceNum);
			
			let currentScore = getBoardDangerScore(currentBoard);
			
			scoreArr.push({piece: possibilities[i], score: currentScore, board: currentBoard});
		}
		
		sortObjectByValue(scoreArr, "score", true);
		
		return scoreArr;
	}
	
	function setCurrentPieceOnBestLocation(){
		let scoreArr = getPossiblePieceLocationRanks();
		
		board = scoreArr[0].board;
		
		
		previousScoreNum = lineClearNums.vertical + lineClearNums.horizontal;
		
		currentPiece.x = scoreArr[0].piece.x;
		currentPiece.y = scoreArr[0].piece.y;
		
		
		clearFullLines(board);
		
		nextPiece(true);
	}
	
	function getBestNonTouchingLocations(){
		let scoreArr = getPossiblePieceLocationRanks();
		
		let nums = [0];
		
		for (let i = 1; i < scoreArr.length; i++){
			let isTouching = false;
			
			for (let num of nums){
				if (arePiecesTouching(scoreArr[i].piece, scoreArr[num].piece)){
					isTouching = true;
				}
			}
			
			if (!isTouching){
				nums.push(i);
			}
		}
		
		
		let arr = [];
		for (let num of nums){
			arr.push(scoreArr[num]);
		}
		
		return arr;
	}
	
</script>
<script> //Multiple-Choice
	
	function refreshMultipleChoiceChoices(){
		if (rules.isMultipleChoiceOrdered){
			multipleChoiceChoices = getBestNonTouchingLocations();
		} else{
			let arr = getBestNonTouchingLocations();
			
			sortObjectBy2DValue(arr, "piece", "x", true);
			
			multipleChoiceChoices = arr;
		}
	}
	
	
	
	function multipleChoiceNextFrame(){
		for (let i = 0; i < multipleChoiceChoices.length; i++){
			
			let digitNum = "Digit" + (i + 1);
			
			if (inputs[digitNum]){
				board = multipleChoiceChoices[i].board;
				
				
				previousScoreNum = lineClearNums.vertical + lineClearNums.horizontal;
				
				currentPiece.x = multipleChoiceChoices[i].piece.x;
				currentPiece.y = multipleChoiceChoices[i].piece.y;
				
				
				clearFullLines(board);
				
				nextPiece(true);
				
				inputs[digitNum] = false;
			}
		}
	}
	
</script>

<script> //Buttons
	
	function buttonsClick(isDown){
		for (let i in buttons){
			for (let j in buttons[i]){
				let scaledPos = getScaledPosition(buttons[i][j].pos);
				
				if (buttons[i][j].isCentered != false){
					scaledPos = getCenterPosition(scaledPos);
				}
				
				if (isVertexInRect(mousePos, scaledPos)){
					if (isDown){
						clickedButton = {i: i, j: j};
					} else{
						if (clickedButton.i === i && clickedButton.j === j){
							let arr = buttons[i][j].onclick;
							
							window[arr.f](arr.args);
						}
					}
				} else{
					let distance = getVertexToRectDistance(mousePos, scaledPos);
					
					if (distance < closestButton.distance || closestButton.distance == -1){
						closestButton = {i: i, j: j, distance: distance};
					}
				}
			}
		}
	}
	
</script>

<script> //General Draw Functions
	
	function getCanvasScaledPositions(pos){
		let scaledArr = structuredClone(pos);
		
		let sizes = {x: canvas.width, y: canvas.height, w: canvas.width, h: canvas.height};
		
		for (let i in scaledArr){
			if (sizes[i] != undefined){
				
				scaledArr[i] *= sizes[i];
			}
		}
		
		if (camera.areDimentionsEqual){
			scaledArr.y *= canvas.width/canvas.height;
			scaledArr.h *= canvas.width/canvas.height;
		}
		
		return scaledArr;
	}
	
	
	function getCenterPosition(pos){
		let arr = structuredClone(pos);
		
		arr.x -= arr.w/2;
		arr.y -= arr.h/2;
		
		return arr;
	}
	
	function calculatePositionWithCamera(arr){
		let pos = {x: arr.x, y: arr.y, w: arr.w, h: arr.h};
		
		if (cameraState.camera){
			let scaledCamera = getCanvasScaledPositions(camera);
			
			pos.x += scaledCamera.x;
			pos.y += scaledCamera.y;
			
			if (cameraState.zoom){
				for (let i in pos){
					pos[i] *= camera.zoom.level;
				}
			}
		} else{
			pos = arr;
		}
		
		return {x: Math.ceil(pos.x + canvas.width/2), y: Math.ceil(pos.y + canvas.height/2), w: Math.ceil(pos.w), h: Math.ceil(pos.h)};
	}
	
	
	function getScaledPosition(pos){
		let scaledPos = getCanvasScaledPositions(pos);
		
		scaledPos = calculatePositionWithCamera(scaledPos);
		
		return scaledPos;
	}
	
	
	function shortFillRect(arr){
		let pos = structuredClone(arr);
		
		ctx.fillRect(pos.x, pos.y, pos.w, pos.h);
	}
	
	function scaledFillRect(pos, isAbsolutePositioned){
		let scaledPos = (isAbsolutePositioned) ? getCanvasScaledPositions(pos) : getScaledPosition(pos);
		
		shortFillRect(scaledPos);
	}
	
	function scaledFillText(text, pos, isAbsolutePositioned){
		let scaledPos = (isAbsolutePositioned) ? getCanvasScaledPositions(pos) : getScaledPosition(pos);
		
		ctx.fillText(text, scaledPos.x, scaledPos.y);
	}
	
</script>
<script> //Draw Buttons
	
	function drawButtons(){
		for (let i in buttons){
			for (let j in buttons[i]){
				let pos = buttons[i][j].pos;
				
				if (buttons[i][j].isCentered != false){
					pos = getCenterPosition(pos, true);
				}
				
				scaledFillRect(pos);
			}
		}
	}
	
</script>
<script> //Draw Board
	
	function drawBlock(x, y, colors){
		ctx.fillStyle = colors[1];
		scaledFillRect({x: x, y: y, w: 1, h: 1});
		
		ctx.fillStyle = colors[0];
		scaledFillRect({x: x + boardData.border, y: y + boardData.border, w: 1 - boardData.border*2, h: 1 - boardData.border*2});
	}
	
	function drawBoard(){
		let currentColors = levelColors[currentLevel] ?? levelColors[0];
		
		for (let i = 0; i < board.length; i++){
			for (let j = 0; j < board[i].length; j++){
				let colorNum = board[i][j].num - 1;
				
				drawBlock(j, i, currentColors[colorNum]);
				
				if (board[i][j].hasFallen){
					drawBlock(j, i, ["#000000","#ffffff"]);
					//drawBlock(j, i, ["hsla(" + Math.round((t/4) % 256) + ",50%,50%,0.1)","hsla(" + Math.round((t/4) % 256) + ",50%,50%,0.333)"]);
				}
				
				if (rules.clearVertical && i == board.length - rules.verticalLineHeight){
					let lineHeight = 0.15;
					
					ctx.fillStyle = "#ffffff22";
					scaledFillRect({x: j, y: i + (0.5 - lineHeight/2), w: 1, h: lineHeight});
				}
			}
		}
	}
	
	
	function drawPiece(x, y, rotationNum, pieceNum, currentColors){
		let pieceArr = pieces[pieceNum][rotationNum];
		
		if (currentColors == undefined){
			currentColors = levelColors[currentLevel] ?? levelColors[0];
		}
		
		for (let i = 0; i < pieceArr.length; i++){
			for (let j = 0; j < pieceArr[i].length; j++){
				if (pieceArr[i][j] != 0){
					let pos = {
						x: x + (j - Math.floor(pieceArr[i].length/2)),
						y: y + (i - Math.floor(pieceArr.length/2))
					}
					
					if (isPosInArr(pos, board)){
						let color = currentColors[(pieceColorsNums[pieceNum] ?? 0)];
						
						if (!Array.isArray(color)){
							color = currentColors;
						}
						
						drawBlock(pos.x, pos.y, color);
					}
				}
			}
		}
		
		if (rules.teleportMovement){
			drawBlock(x, y, ["#AAAAAA","#f0f0f0"]);
		}
	}
	
	function drawCurrentPiece(){
		drawPiece(currentPiece.x, currentPiece.y, currentPiece.rotationNum, currentPiece.pieceNum);
	}
	
	
	function drawNextPieces(){ //this could use drawPiece
		for (let k = 0; k < nextPieceNums.length; k++){
			if (k < rules.nextPieceDepth){
				let pieceArr = pieces[nextPieceNums[k]][0];
				
				let currentColors = levelColors[currentLevel] ?? levelColors[0];
				
				for (let i = 0; i < pieceArr.length; i++){
					for (let j = 0; j < pieceArr[i].length; j++){
						if (pieceArr[i][j] != 0){
							let pos = {
								x: 13 + (j - Math.floor(pieceArr[i].length/2)),
								y: 9 + (i - Math.floor(pieceArr.length/2)) + k*3.5
							}
							
							if (nextPieceNums.length > 3){
								pos.x += Math.floor(k / 6) * 4.5;
								
								pos.y = 0.5 + (i - Math.floor(pieceArr.length/2)) + (k % 6)*3.5;
								
							}
							
							drawBlock(pos.x, pos.y, currentColors[(pieceColorsNums[nextPieceNums[k]] ?? 0)]);
						}
					}
				}
			}
		}
	}
	
	
	function drawMultipleChoiceChoices(){
		ctx.font = Math.floor(canvas.width/42) + "px Consolas";
		
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		
		for (let i = 0; i < multipleChoiceChoices.length; i++){
			let arr = multipleChoiceChoices[i].piece;
			
			let currentColor = ghostColors[i] ?? ghostColors[0];
			
			let colorsArr = [currentColor, currentColor];
			
			drawPiece(arr.x, arr.y, arr.rotationNum, currentPiece.pieceNum, colorsArr);
			
			
			let textColor = currentColor.substring(0, 7).replaceAll("88", "FF").replaceAll("44", "00");
			
			ctx.fillStyle = colors.black;
			scaledFillText(i + 1, {x: arr.x + 0.55, y: arr.y + 0.55});
			
			ctx.fillStyle = textColor;
			scaledFillText(i + 1, {x: arr.x + 0.5, y: arr.y + 0.5});
		}
	}
	
</script>
<script> //Draw Hud Stats
	
	function drawLineClearNums(){
		ctx.fillStyle = colors.white;
			ctx.textAlign = "center";
		
		if (rules.clearHorizontal && rules.clearVertical){
			ctx.font = Math.floor(canvas.width/90) + "px Consolas";
			
			scaledFillText("Vertical Lines: " + lineClearNums.vertical, {x: 5, y: -2});
			scaledFillText("Horizontal Lines: " + lineClearNums.horizontal, {x: 5, y: -1});
			
		} else if (rules.clearHorizontal || rules.clearVertical){
			ctx.font = Math.floor(canvas.width/45) + "px Consolas";
			
			let linesNum = (rules.clearHorizontal) ? lineClearNums.horizontal : lineClearNums.vertical;
			
			scaledFillText("Lines: " + linesNum, {x: 5, y: -1.5});
		}
	}
	
	function drawCursedPieceChances(){
		if (rules.cursedPiecesChance != 0){
			ctx.fillStyle = colors.white;
			ctx.font = Math.floor(canvas.width/90) + "px Consolas";
			ctx.textAlign = "left";
			
			let chance = getCursedPiecesChance();
			
			chanceText = (Math.round(chance * 10000) / 100) + "%";
			
			if (chanceText == "0%"){ chanceText = "~0%"; }
			
			
			scaledFillText(chanceText + " Cursed Piece Chance", {x: 11, y: -1.5});
			
			//scaledFillText("danger: " + getBoardDangerScore(board), {x: 16.5, y: 3.5});
		}
	}
	
	
	function drawControls(){
		if (shouldDrawControls){
			ctx.fillStyle = "#ffffff44";
			ctx.font = Math.floor(canvas.width/90) + "px Consolas";
			ctx.textAlign = "center";
			
			let pos = {x: -11.5, y: 15, gapY: 0.875};
			
			pos.x -= (rules.teleportMovement) ? 1 : 0;
			pos.y -= (rules.teleportMovement) ? 1 : 0;
			
			
			scaledFillText("Controls: ", {x: pos.x, y: pos.y + pos.gapY*-0.5});
			
			if (rules.teleportMovement){
				scaledFillText("Movement: ASDFGHJKL;", {x: pos.x, y: pos.y + pos.gapY*1});
				scaledFillText("Left Rotation: QWERTZXCVB", {x: pos.x, y: pos.y + pos.gapY*2});
				scaledFillText("Right Rotation: YUIOP[]NM,./", {x: pos.x, y: pos.y + pos.gapY*3});
				scaledFillText("Down: Space", {x: pos.x, y: pos.y + pos.gapY*4});
			} else{
				scaledFillText("Movement: Arrows", {x: pos.x, y: pos.y + pos.gapY*1});
				scaledFillText("Rotation: Z X", {x: pos.x, y: pos.y + pos.gapY*2});
			}
		}
	}
	
</script>
<script> //Draw Call
	
	function draw(){
		canvas.width |= 0;
		
		ctx.fillStyle = colors.background;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		
		drawBoard();
		
		if (isCurrentlyMultipleChoice){
			drawMultipleChoiceChoices();
		} else{
			drawCurrentPiece();
		}
		
		drawNextPieces();
		
		drawLineClearNums();
		drawCursedPieceChances();
		
		if (lineClearNums.vertical + lineClearNums.horizontal == 0){
			drawControls();
		}
		
		drawButtons();
	}
	
</script>

<script> //Next Frame
	
	let shouldPauseNextFrame = false;
	
	let lastFrameTime = getCurrentTime();
	let currentFrameTime = getCurrentTime();
	let wasPreviousCatchUpFrame = false;
	
	function nextFrame(){
		t++;
		
		gamepads = navigator.getGamepads();
		
		
		if (rules.solverTimer.num <= 0){
			if (isCurrentlyMultipleChoice){
				multipleChoiceNextFrame();
			} else{
				refreshButtonPressStates();
				
				moveCurrentPiece();
			}
		} else{
			rules.solverTimer.num--;
			
			if (rules.solverTimer.num == 0){
				setCurrentPieceOnBestLocation();
			}
		}
		
		if (rules.pieceGravity && rules.gravityTimer.max > 0){
			rules.gravityTimer.num--;
			
			if (rules.gravityTimer.num <= 0){
				gravityNextFrame();
				
				rules.gravityTimer.num = rules.gravityTimer.max;
			}
		}
		
		
		draw();
		
		
		if (mouseLockFrames <= 1){
			mouseLockFrames++;
		}
		
		
		
		currentFrameTime = getCurrentTime();
		
		
		let nextFrameDelay = 1000/fps;
		
		if (!wasPreviousCatchUpFrame){
			nextFrameDelay = (1000/fps * 2) - (currentFrameTime - lastFrameTime);
			
			nextFrameDelay = Math.min(nextFrameDelay, 1);
			
			wasPreviousCatchUpFrame = true;
		} else{
			wasPreviousCatchUpFrame = false;
		}
		
		lastFrameTime = getCurrentTime();
		
		if (!shouldPauseNextFrame){
			setTimeout(nextFrame, nextFrameDelay);
		}
	}
	
</script>

<script> //Zoom
	
	function isMovingCamera(){
		return (isMouseDown && mouseButton != 1 && mouseLockFrames > 1);
	}
	
	function cameraMouseDown(){
		if (cameraState.camera && cameraState.shouldLockMouse){
			if(canvas.requestPointerLock){
				canvas.requestPointerLock();
			}else {
				canvas.mozRequestPointerLock();
			}
			
			mouseLockFrames = 0;
		}
	}
	
	function cameraMouseUp(){
		if (cameraState.camera && cameraState.shouldLockMouse){
			if(document.exitPointerLock){
				document.exitPointerLock();
			} else{
				document.mozExitPointerLock();
			}
		}
	}
	
	function cameraMouseMove(){
		if (cameraState.camera){
			if (isMovingCamera()){
				let speed = {
					x: event.movementX / canvas.width,
					y: event.movementY / canvas.height
				}
				
				if (cameraState.zoom){
					speed.x *= (camera.zoom.min / camera.zoom.level) * camera.zoom.speed;
					speed.y *= (camera.zoom.min / camera.zoom.level) * camera.zoom.speed;
				}
				
				camera.x -= speed.x * camera.speed;
				camera.y -= speed.y * camera.speed;
			}
		}
	}
	
	
	function zoomWheel(event){
		if (cameraState.zoom){
			let zoom = camera.zoom;
			
			zoom.level -= event.deltaY * zoom.scrollSpeed;
			
			zoom.level = getNumInRange(zoom.level, zoom.min, zoom.max);
			
			draw();
		}
	}
	
</script>

<script> //Listeners
	
	//Resize
	
	function onResize(){
		canvas.height = window.innerHeight;
		canvas.width = window.innerWidth;
		
		draw();
	}
	
	window.addEventListener("resize",onResize);
	
	
	//Inputs
	
	let inputs = []; //ex: inputs.KeyW
	
	function setKeyDown(e){
		e = e || window.event;
		inputs[e.code] = true;
		
		if (isInRebindControls){
			if (selectedRebindButton != ""){
				let i = inputButtons[selectedRebindButton].keyboard.indexOf(e.code);
				
				if (i == -1){
					inputButtons[selectedRebindButton].keyboard.push(e.code);
				} else{
					inputButtons[selectedRebindButton].keyboard.splice(i, 1);
				}
				
				generateRebindControlsMenu();
			}
		}
	}
	
	function setKeyUp(e){
		e = e || window.event;
		inputs[e.code] = false;
	}
	
	document.onkeydown = setKeyDown;
	document.onkeyup = setKeyUp;
	
	
	//Mouse
	
	function onMouseDown(event){
		setMousePos(canvas, event);
		
		isMouseDown = true;
		mouseButton = event.buttons;
		
		if (mouseButton != 1){
			cameraMouseDown();
		}
		
		if (mouseButton == 1){
			buttonsClick(true);
		} else{
			clickedButton = {i: "", j: 0};
		}
	}
	
	function onMouseUp(event){
		setMousePos(canvas, event);
		
		isMouseDown = false;
		
		buttonsClick(false);
		clickedButton = {i: "", j: 0};
		
		cameraMouseUp();
	}
	
	function onMouseMove(event){
		setMousePos(canvas, event);
		
		let directions = getVertexToVertexDirection(mousePos, lastMousePos);
		let distance = getVertexDistance(mousePos, lastMousePos);
		
		if (isMovingCamera()){
			cameraMouseMove();
		} else{
			for (let i = 0; i < distance; i+=0.5){
				let currentPos = {
					x: mousePos.x + i * directions.x,
					y: mousePos.y + i * directions.y
				};
				
				
				//mouse move
			}
		}
	}
	
	
	function setMousePos(c, event) {
		let rect = c.getBoundingClientRect();
		
		lastMousePos = mousePos;
		lastMousePosRatio = mousePosRatio;
		
		mousePos = {
			x: event.clientX - rect.left,
			y: event.clientY - rect.top
		};
		
		mousePosRatio = {x: mousePos.x / c.width, y: mousePos.y / c.height};
	}
	
	canvas.addEventListener("mousedown", onMouseDown);
	canvas.addEventListener("mouseup", onMouseUp);
	canvas.addEventListener('mousemove',onMouseMove);
	canvas.addEventListener('wheel', zoomWheel, {passive: true});
	
</script>

<script> //Calls
	generateMenu();
  </script>
 </body>
</html>
